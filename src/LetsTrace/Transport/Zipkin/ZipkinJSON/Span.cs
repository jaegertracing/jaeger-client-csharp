/*
 * Zipkin API
 *
 * Zipkin's v2 api currently includes a POST endpoint that can receive spans. 
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using Newtonsoft.Json;

namespace LetsTrace.Transport.Zipkin.ZipkinJSON
{ 
    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class Span : IEquatable<Span>
    { 
        /// <summary>
        /// Randomly generated, unique identifier for a trace, set on all spans within it.  Encoded as 16 or 32 lowercase hex characters corresponding to 64 or 128 bits. For example, a 128bit trace ID looks like 4e441824ec2b6a44ffdc9bb9a6453df3 
        /// </summary>
        /// <value>Randomly generated, unique identifier for a trace, set on all spans within it.  Encoded as 16 or 32 lowercase hex characters corresponding to 64 or 128 bits. For example, a 128bit trace ID looks like 4e441824ec2b6a44ffdc9bb9a6453df3 </value>
        [DataMember(Name="traceId")]
        public string TraceId { get; set; }

        /// <summary>
        /// The logical operation this span represents in lowercase (e.g. rpc method). Leave absent if unknown.  As these are lookup labels, take care to ensure names are low cardinality. For example, do not embed variables into the name. 
        /// </summary>
        /// <value>The logical operation this span represents in lowercase (e.g. rpc method). Leave absent if unknown.  As these are lookup labels, take care to ensure names are low cardinality. For example, do not embed variables into the name. </value>
        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// The parent span ID or absent if this the root span in a trace.
        /// </summary>
        /// <value>The parent span ID or absent if this the root span in a trace.</value>
        [DataMember(Name="parentId")]
        public string ParentId { get; set; }

        /// <summary>
        /// Unique 64bit identifier for this operation within the trace.  Encoded as 16 lowercase hex characters. For example ffdc9bb9a6453df3 
        /// </summary>
        /// <value>Unique 64bit identifier for this operation within the trace.  Encoded as 16 lowercase hex characters. For example ffdc9bb9a6453df3 </value>
        [DataMember(Name="id")]
        public string Id { get; set; }
        /// <summary>
        /// When present, clarifies timestamp, duration and remoteEndpoint. When absent, the span is local or incomplete. Unlike client and server, there is no direct critical path latency relationship between producer and consumer spans.  * `CLIENT`   * timestamp - The moment a request was sent (formerly \"cs\")   * duration - When present indicates when a response was received (formerly \"cr\")   * remoteEndpoint - Represents the server. Leave serviceName absent if unknown. * `SERVER`   * timestamp - The moment a request was received (formerly \"sr\")   * duration - When present indicates when a response was sent (formerly \"ss\")   * remoteEndpoint - Represents the client. Leave serviceName absent if unknown. * `PRODUCER`   * timestamp - The moment a message was sent to a destination (formerly \"ms\")   * duration - When present represents delay sending the message, such as batching.   * remoteEndpoint - Represents the broker. Leave serviceName absent if unknown. * `CONSUMER`   * timestamp - The moment a message was received from an origin (formerly \"mr\")   * duration - When present represents delay consuming the message, such as from backlog.   * remoteEndpoint - Represents the broker. Leave serviceName absent if unknown. 
        /// </summary>
        /// <value>When present, clarifies timestamp, duration and remoteEndpoint. When absent, the span is local or incomplete. Unlike client and server, there is no direct critical path latency relationship between producer and consumer spans.  * `CLIENT`   * timestamp - The moment a request was sent (formerly \"cs\")   * duration - When present indicates when a response was received (formerly \"cr\")   * remoteEndpoint - Represents the server. Leave serviceName absent if unknown. * `SERVER`   * timestamp - The moment a request was received (formerly \"sr\")   * duration - When present indicates when a response was sent (formerly \"ss\")   * remoteEndpoint - Represents the client. Leave serviceName absent if unknown. * `PRODUCER`   * timestamp - The moment a message was sent to a destination (formerly \"ms\")   * duration - When present represents delay sending the message, such as batching.   * remoteEndpoint - Represents the broker. Leave serviceName absent if unknown. * `CONSUMER`   * timestamp - The moment a message was received from an origin (formerly \"mr\")   * duration - When present represents delay consuming the message, such as from backlog.   * remoteEndpoint - Represents the broker. Leave serviceName absent if unknown. </value>

        /// <summary>
        /// When present, clarifies timestamp, duration and remoteEndpoint. When absent, the span is local or incomplete. Unlike client and server, there is no direct critical path latency relationship between producer and consumer spans.  * &#x60;CLIENT&#x60;   * timestamp - The moment a request was sent (formerly \&quot;cs\&quot;)   * duration - When present indicates when a response was received (formerly \&quot;cr\&quot;)   * remoteEndpoint - Represents the server. Leave serviceName absent if unknown. * &#x60;SERVER&#x60;   * timestamp - The moment a request was received (formerly \&quot;sr\&quot;)   * duration - When present indicates when a response was sent (formerly \&quot;ss\&quot;)   * remoteEndpoint - Represents the client. Leave serviceName absent if unknown. * &#x60;PRODUCER&#x60;   * timestamp - The moment a message was sent to a destination (formerly \&quot;ms\&quot;)   * duration - When present represents delay sending the message, such as batching.   * remoteEndpoint - Represents the broker. Leave serviceName absent if unknown. * &#x60;CONSUMER&#x60;   * timestamp - The moment a message was received from an origin (formerly \&quot;mr\&quot;)   * duration - When present represents delay consuming the message, such as from backlog.   * remoteEndpoint - Represents the broker. Leave serviceName absent if unknown. 
        /// </summary>
        /// <value>When present, clarifies timestamp, duration and remoteEndpoint. When absent, the span is local or incomplete. Unlike client and server, there is no direct critical path latency relationship between producer and consumer spans.  * &#x60;CLIENT&#x60;   * timestamp - The moment a request was sent (formerly \&quot;cs\&quot;)   * duration - When present indicates when a response was received (formerly \&quot;cr\&quot;)   * remoteEndpoint - Represents the server. Leave serviceName absent if unknown. * &#x60;SERVER&#x60;   * timestamp - The moment a request was received (formerly \&quot;sr\&quot;)   * duration - When present indicates when a response was sent (formerly \&quot;ss\&quot;)   * remoteEndpoint - Represents the client. Leave serviceName absent if unknown. * &#x60;PRODUCER&#x60;   * timestamp - The moment a message was sent to a destination (formerly \&quot;ms\&quot;)   * duration - When present represents delay sending the message, such as batching.   * remoteEndpoint - Represents the broker. Leave serviceName absent if unknown. * &#x60;CONSUMER&#x60;   * timestamp - The moment a message was received from an origin (formerly \&quot;mr\&quot;)   * duration - When present represents delay consuming the message, such as from backlog.   * remoteEndpoint - Represents the broker. Leave serviceName absent if unknown. </value>
        [DataMember(Name="kind")]
        public KindEnum? Kind { get; set; }

        /// <summary>
        /// Epoch **microseconds** of the start of this span, possibly absent if incomplete.  For example, 1502787600000000 corresponds to 2017-08-15 09:00 UTC  This value should be set directly by instrumentation, using the most precise value possible. For example, gettimeofday or multiplying epoch millis by 1000.  There are three known edge-cases where this could be reported absent.  * A span was allocated but never started (ex not yet received a timestamp)  * The span&#39;s start event was lost  * Data about a completed span (ex tags) were sent after the fact 
        /// </summary>
        /// <value>Epoch **microseconds** of the start of this span, possibly absent if incomplete.  For example, 1502787600000000 corresponds to 2017-08-15 09:00 UTC  This value should be set directly by instrumentation, using the most precise value possible. For example, gettimeofday or multiplying epoch millis by 1000.  There are three known edge-cases where this could be reported absent.  * A span was allocated but never started (ex not yet received a timestamp)  * The span&#39;s start event was lost  * Data about a completed span (ex tags) were sent after the fact </value>
        [DataMember(Name="timestamp")]
        public long? Timestamp { get; set; }

        /// <summary>
        /// Duration in **microseconds** of the critical path, if known. Durations of less than one are rounded up. Duration of children can be longer than their parents due to asynchronous operations.  For example 150 milliseconds is 150000 microseconds. 
        /// </summary>
        /// <value>Duration in **microseconds** of the critical path, if known. Durations of less than one are rounded up. Duration of children can be longer than their parents due to asynchronous operations.  For example 150 milliseconds is 150000 microseconds. </value>
        [DataMember(Name="duration")]
        public long? Duration { get; set; }

        /// <summary>
        /// True is a request to store this span even if it overrides sampling policy.  This is true when the &#x60;X-B3-Flags&#x60; header has a value of 1. 
        /// </summary>
        /// <value>True is a request to store this span even if it overrides sampling policy.  This is true when the &#x60;X-B3-Flags&#x60; header has a value of 1. </value>
        [DataMember(Name="debug")]
        public bool? Debug { get; set; }

        /// <summary>
        /// True if we are contributing to a span started by another tracer (ex on a different host).
        /// </summary>
        /// <value>True if we are contributing to a span started by another tracer (ex on a different host).</value>
        [DataMember(Name="shared")]
        public bool? Shared { get; set; }

        /// <summary>
        /// The host that recorded this span, primarily for query by service name.  Instrumentation should always record this. Usually, absent implies late data. The IP address corresponding to this is usually the site local or advertised service address. When present, the port indicates the listen port. 
        /// </summary>
        /// <value>The host that recorded this span, primarily for query by service name.  Instrumentation should always record this. Usually, absent implies late data. The IP address corresponding to this is usually the site local or advertised service address. When present, the port indicates the listen port. </value>
        [DataMember(Name="localEndpoint")]
        public Endpoint LocalEndpoint { get; set; }

        /// <summary>
        /// When an RPC (or messaging) span, indicates the other side of the connection. 
        /// </summary>
        /// <value>When an RPC (or messaging) span, indicates the other side of the connection. </value>
        [DataMember(Name="remoteEndpoint")]
        public Endpoint RemoteEndpoint { get; set; }

        /// <summary>
        /// Associates events that explain latency with the time they happened.
        /// </summary>
        /// <value>Associates events that explain latency with the time they happened.</value>
        [DataMember(Name="annotations")]
        public List<Annotation> Annotations { get; set; }

        /// <summary>
        /// Tags give your span context for search, viewing and analysis.
        /// </summary>
        /// <value>Tags give your span context for search, viewing and analysis.</value>
        [DataMember(Name="tags")]
        public Dictionary<string, string> Tags { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Span {\n");
            sb.Append("  TraceId: ").Append(TraceId).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  ParentId: ").Append(ParentId).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Kind: ").Append(Kind).Append("\n");
            sb.Append("  Timestamp: ").Append(Timestamp).Append("\n");
            sb.Append("  Duration: ").Append(Duration).Append("\n");
            sb.Append("  Debug: ").Append(Debug).Append("\n");
            sb.Append("  Shared: ").Append(Shared).Append("\n");
            sb.Append("  LocalEndpoint: ").Append(LocalEndpoint).Append("\n");
            sb.Append("  RemoteEndpoint: ").Append(RemoteEndpoint).Append("\n");
            sb.Append("  Annotations: ").Append(Annotations).Append("\n");
            sb.Append("  Tags: ").Append(Tags).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson() => JsonConvert.SerializeObject(this);

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((Span)obj);
        }

        /// <summary>
        /// Returns true if Span instances are equal
        /// </summary>
        /// <param name="other">Instance of Span to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Span other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    TraceId == other.TraceId ||
                    TraceId != null &&
                    TraceId.Equals(other.TraceId)
                ) && 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    ParentId == other.ParentId ||
                    ParentId != null &&
                    ParentId.Equals(other.ParentId)
                ) && 
                (
                    Id == other.Id ||
                    Id != null &&
                    Id.Equals(other.Id)
                ) && 
                (
                    Kind == other.Kind ||
                    Kind != null &&
                    Kind.Equals(other.Kind)
                ) && 
                (
                    Timestamp == other.Timestamp ||
                    Timestamp != null &&
                    Timestamp.Equals(other.Timestamp)
                ) && 
                (
                    Duration == other.Duration ||
                    Duration != null &&
                    Duration.Equals(other.Duration)
                ) && 
                (
                    Debug == other.Debug ||
                    Debug != null &&
                    Debug.Equals(other.Debug)
                ) && 
                (
                    Shared == other.Shared ||
                    Shared != null &&
                    Shared.Equals(other.Shared)
                ) && 
                (
                    LocalEndpoint == other.LocalEndpoint ||
                    LocalEndpoint != null &&
                    LocalEndpoint.Equals(other.LocalEndpoint)
                ) && 
                (
                    RemoteEndpoint == other.RemoteEndpoint ||
                    RemoteEndpoint != null &&
                    RemoteEndpoint.Equals(other.RemoteEndpoint)
                ) && 
                (
                    Annotations == other.Annotations ||
                    Annotations != null &&
                    Annotations.SequenceEqual(other.Annotations)
                ) && 
                (
                    Tags == other.Tags ||
                    Tags != null &&
                    Tags.Equals(other.Tags)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (TraceId != null)
                    hashCode = hashCode * 59 + TraceId.GetHashCode();
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (ParentId != null)
                    hashCode = hashCode * 59 + ParentId.GetHashCode();
                    if (Id != null)
                    hashCode = hashCode * 59 + Id.GetHashCode();
                    if (Kind != null)
                    hashCode = hashCode * 59 + Kind.GetHashCode();
                    if (Timestamp != null)
                    hashCode = hashCode * 59 + Timestamp.GetHashCode();
                    if (Duration != null)
                    hashCode = hashCode * 59 + Duration.GetHashCode();
                    if (Debug != null)
                    hashCode = hashCode * 59 + Debug.GetHashCode();
                    if (Shared != null)
                    hashCode = hashCode * 59 + Shared.GetHashCode();
                    if (LocalEndpoint != null)
                    hashCode = hashCode * 59 + LocalEndpoint.GetHashCode();
                    if (RemoteEndpoint != null)
                    hashCode = hashCode * 59 + RemoteEndpoint.GetHashCode();
                    if (Annotations != null)
                    hashCode = hashCode * 59 + Annotations.GetHashCode();
                    if (Tags != null)
                    hashCode = hashCode * 59 + Tags.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(Span left, Span right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(Span left, Span right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
