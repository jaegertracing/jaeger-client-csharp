using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;

namespace LetsTrace.Metrics
{
    public abstract partial class BaseMetricsFactory
    {
        private sealed class TypeConstructor
        {
            private static readonly ModuleBuilder ModuleBuilder;

            private Type Type { get; }
            private PropertyGrouping Properties { get; }

            static TypeConstructor()
            {
                var assemblyName = new AssemblyName("OpenTracing.Jaeger.Metrics.Dynamic");
                var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
                ModuleBuilder = assemblyBuilder.DefineDynamicModule("JaegerAutoGeneratedModule");
            }

            public TypeConstructor()
            {
                var interfaceType = typeof(IMetrics);
                var typeBuilder = ModuleBuilder.DefineType("GenericMetrics", TypeAttributes.Public | TypeAttributes.Sealed);
                typeBuilder.AddInterfaceImplementation(interfaceType);

                this.Properties = this.HandleProperties(typeBuilder, interfaceType);

                try
                {
                    this.Type = typeBuilder.CreateTypeInfo().AsType();
                }
                catch (TypeLoadException e)
                {
                    throw new Exception($"Unable to create implementation for interface {interfaceType.FullName}", e);
                }
            }

            public IMetrics CreateMetrics(BaseMetricsFactory factory)
            {
                var metrics = (IMetrics)Activator.CreateInstance(this.Type);
                var fields = metrics.GetType().GetRuntimeFields().ToDictionary(p => p.Name, p => p);
                foreach (var property in this.Properties.Metric)
                {
                    var field = fields[property.BackingField.Name];

                    if (field.FieldType == typeof(ICounter))
                        field.SetValue(metrics, factory.CreateCounter(property.PropertyInfo.Name, property.Attribute));
                    else if (field.FieldType == typeof(IGauge))
                        field.SetValue(metrics, factory.CreateGauge(property.PropertyInfo.Name, property.Attribute));
                    else if (field.FieldType == typeof(ITimer))
                        field.SetValue(metrics, factory.CreateTimer(property.PropertyInfo.Name, property.Attribute));
                }

                return metrics;
            }

            private IEnumerable<T> InterfaceAndChildren<T>(Type interfaceType, Func<Type, IEnumerable<T>> selector)
            {
                foreach (var item in selector(interfaceType))
                {
                    yield return item;
                }
                foreach (var child in interfaceType.GetTypeInfo().GetInterfaces())
                {
                    foreach (var item in selector(child))
                    {
                        yield return item;
                    }
                }
            }

            private PropertyGrouping HandleProperties(TypeBuilder typeBuilder, Type interfaceType)
            {
                var grouping = new PropertyGrouping(InterfaceAndChildren(interfaceType, x => x.GetTypeInfo().GetProperties()));
                MethodAttributes attributes = MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.SpecialName;

                foreach (var property in grouping.Metric)
                {
                    var propertyBuilder = typeBuilder.DefineProperty(property.PropertyInfo.Name, PropertyAttributes.None, property.PropertyInfo.PropertyType, null);
                    var getter = typeBuilder.DefineMethod(property.PropertyInfo.GetMethod.Name, attributes, property.PropertyInfo.PropertyType, new Type[0]);
                    var backingField = typeBuilder.DefineField("bk_" + property.PropertyInfo.Name, property.PropertyInfo.PropertyType, FieldAttributes.Private);

                    var getterIlGenerator = getter.GetILGenerator();
                    getterIlGenerator.Emit(OpCodes.Ldarg_0);
                    getterIlGenerator.Emit(OpCodes.Ldfld, backingField);
                    getterIlGenerator.Emit(OpCodes.Ret);
                    propertyBuilder.SetGetMethod(getter);

                    property.BackingField = backingField;
                }

                return grouping;
            }
        }
    }
}